:: js [script]

// Config.debug = true;

window.setup = {};
window.setup.$tooltips = [];
window.setup.poppers = [];

// Ex. When the UI Bar changes from stowed
window.setup.updatePoppers = function() {
    window.setup.poppers.forEach(function(p) { p.update(); });
}

window.setup.hideActions = function() {
    $("#action-bar").attr("data-hide", "true");
}

window.setup.showActions = function() {
    $("#action-bar").attr("data-hide", "false");
}

window.setup.unreadMessagesCount = function() {
    if (Array.isArray(State.variables.messages)) {
        const found = State.variables.messages.filter(function(message) { return !message.read; });
        return found.length;
    }

    return 0;
}

window.setup.addMessage = function(newMessage) {
    if (Array.isArray(State.variables.messages)) {
        const existing = State.variables.messages.find(function(message) {
            return newMessage.subject === message.subject &&
                newMessage.from === message.from &&
                newMessage.body === message.body;
        });

        if (!existing) {
            State.variables.messages.push(newMessage);
            UIBar.update();
        }
    }
}

const addMacros = function() {
    // Tooltip Macro
    Macro.add("tooltip", {
        tags: null,
        handler: function() {
            if (!window.Popper) {
                // Popper is not initialized, don't do anything.
                // The passage will be re-rendered once it's here.
                return;
            }
            const tooltipText = this.args[0]
            const direction = this.args[1] ||  "auto";
            const payload = (this.payload || []).find(p => p.name === "tooltip");
            const text = (payload || {}).contents || "trigger";
            
            const tooltipContent = $("<div>")
                .addClass("tooltip-text")
                .data("show", "false")
                .append(
                    tooltipText,
                    $("<div>").addClass("arrow").attr("data-popper-arrow", "")
                )
            
            const tooltipTrigger = $("<span>")
                .addClass(`tooltip-trigger`)
                .attr("aria-describedby", "tooltip")
                .html(text)
                .on("mouseenter", function() {
                    tooltipContent.attr("data-show", "true");
                })
                .on("mouseleave", function() {
                    tooltipContent.attr("data-show", "false");
                });
            
            $(this.output).append(tooltipTrigger);
            $(document.body).append(tooltipContent);
            window.setup.$tooltips.push(tooltipContent);
            
            const popperInstance = Popper.createPopper(tooltipTrigger.get(0), tooltipContent.get(0), {
                placement: direction || 'auto',
                modifiers: [
                    {
                        name: 'offset',
                        options: {
                            offset: function({placement, reference, popper}) {
                                // Top and Bottom don't need adjustment, but left and right do.
                                if (placement.indexOf("top") === 0 || placement.indexOf("bottom") === 0) {
                                    return [];
                                } else {
                                    return [0, 8];
                                }
                            },
                        }
                    }
                ]
            });
            window.setup.poppers.push(popperInstance);
        }
    });
}

function setupUIBarObserver() {
    if (!window.MutationObserver) {
        return;
    }

    const observer = new MutationObserver(function(mutationsList) {
        mutationsList.forEach(function(mutation) {
            if (mutation.type === "attributes" && mutation.attributeName === "class") {
                // class changed, we aren't worried about what happened
                // Wait for the animation to finish though.
                setTimeout(function() {
                    window.setup.updatePoppers && window.setup.updatePoppers();
                }, 250);
            }
        })
    });

    observer.observe(document.querySelector("#ui-bar"), { attributes: true });
}

window.setup.init = function() {
    $(document).on(":passageinit", function() {
        // Setup Player first and last name
        let playerName = State.getVar("$playerName") || "";

        if (!State.getVar("$playerFirstName")) {
            const parts = playerName.split(/\s+/);
            State.setVar("$playerFirstName", parts[0]);
            State.setVar("$playerLastName", parts[parts.length -1]);
        }

        // Clear old popups
        window.setup.$tooltips.forEach(function($tooltip) {
            $tooltip.remove();
        });
        window.setup.$tooltips = [];
    });

    $(document).on(":passagerender", function(e) {
        $(e.content).find("button.link-broken").prop("disabled", true);
    });

    addMacros();
    setupUIBarObserver();

    const lock = LoadScreen.lock();
    return importScripts("https://unpkg.com/@popperjs/core@2")
        .then(function () {
            window.setup.JSLoaded = true;
            Engine.play(passage(), true);
            LoadScreen.unlock(lock);
        })
        .catch(function(e){ console.error(e); })
};

window.setup.init();
